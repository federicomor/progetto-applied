---
title: "R Notebook"
# output: html_notebook
editor_options:
  chunk_output_type: inline
---

```{r}
library(car)
library(MVN)
library(mvtnorm)
library(mvnormtest)

library(ggplot2)
library(grid)
library(sf)
library(dplyr)
library(rnaturalearth)

library(sp)

library(ggrepel)
library(tmap)
library(knitr)

```


```{r}
root_proj_dir = "../../"
path_social = paste(root_proj_dir,"data/data_social_woo.csv",sep="")
path_psych = paste(root_proj_dir,"data/data_psych_woo.csv",sep="")
include_path = paste(root_proj_dir,"src/include/Utilities.R",sep="")
#INCLUDING UTILITIES
source(include_path)
#IMPORTING THE DATASET
df_social <- read.csv(file=path_social)
df_psych <- read.csv(file=path_psych)
```

# On social
```{r}
colnames(df_social)

##### Scegline uno per volta #####
covariates <- readLines("../../data/non csv/lm_social_vars.txt")
# covariates <- readLines("../../data/non csv/lm_psico_vars.txt")
##### Scegline uno per volta #####

targets = c(
	"Social.well.being",
	"Psychological.well.being"
)

model_variables = c(covariates,targets)
Glabel = factor(df_social$CNT)
Blabel = factor(df_social$IM_PUBLIC)
GBlabel = factor(df_social$NEW_VAR)
```

## [1] Anova with CNT
```{r}
treat = levels(Glabel)
g = length(treat)
ncols = length(levels(Glabel))+2
RADAR_MATRIX = data.frame(matrix(0,ncols,length(model_variables)))
colnames(RADAR_MATRIX) = model_variables
rownames(RADAR_MATRIX) = c("max","min",levels(Glabel))
RADAR_MATRIX
```

```{r}
for (j in 1:length(model_variables) ){
# for (j in 1:3 ){
	Xtarget = data.frame(df_social[,model_variables[j]])
	# fit_complete = aov(as.matrix(Xtarget) ~ Glabel + Blabel + Glabel:Blabel)
	fit_complete = aov(as.matrix(Xtarget) ~ Glabel)
	print(model_variables[j])
	print(summary.aov(fit_complete))
	print("######################################")
}
```


```{r}
for (j in 1:length(model_variables) ){
# for (j in 1:3 ){
	Xtarget = data.frame(df_social[,model_variables[j]])
	# fit_complete = aov(as.matrix(Xtarget) ~ Glabel + Blabel + Glabel:Blabel)
	fit_complete = aov(as.matrix(Xtarget) ~ Glabel)
	print(model_variables[j])
	print(summary.aov(fit_complete))
	
	Xtarget = as.numeric(Xtarget[,])
	mu = mean(Xtarget)
	
	print(paste("mu =",mu))
	tau_i=NULL
	for (i in 1:g){
	print(paste0("tau_",i,"(",treat[i],") = ",mean(Xtarget[Glabel==treat[i]])-mu))
	tau_i = c(tau_i,mean(Xtarget[Glabel==treat[i]])-mu)
	RADAR_MATRIX[i+2,j] = mean(Xtarget[Glabel==treat[i]])-mu
	}
	# sigma2 = var(Xtarget-mu-tau_i[as.numeric(Glabel)])
	# print(paste("sigmaˆ2 =",sigma2))
	# print(paste("sigmaˆ2 =",var(residuals(fit))))
}
RADAR_MATRIX
```

```{r}
for(j in 1:length(model_variables)){
	RADAR_MATRIX[3:ncols,j] = RADAR_MATRIX[3:ncols,j] + abs(min(RADAR_MATRIX[3:ncols,j]))
	RADAR_MATRIX[1,j] = max(RADAR_MATRIX[3:ncols,j])
	RADAR_MATRIX[2,j] = min(RADAR_MATRIX[3:ncols,j])
}
RADAR_MATRIX
```



```{r}
# install.packages("fmsb")
library(fmsb)
for(i in 1:g){
	# show(avg_vals_df[c(1,2,i+2),])
	radarchart(RADAR_MATRIX[c(1,2,i+2),],title=treat[i],cex=0.3)
}
```


```{r}
# [1] "#6B0077" "#7C7BB2"
# [3] "#A7C6DD" "#F1F1F1"

# prima color era questo #1A8FBF
create_beautiful_radarchart <- function(data, color = "#7C7BB2", 
                                        vlabels = colnames(data), vlcex = 0.8,
                                        caxislabels = NULL, title = NULL, ...){
  radarchart(
    data, axistype =0, calcex=0.7,
    # Customize the polygon
    pcol = color, pfcol = scales::alpha(color, 0.3), plwd = 2, plty = 1,
    # Customize the grid
    # cglcol = "#BBBBBB", cglty = 1, cglwd = 0.8,
    cglcol = "#C1C1C1", cglty = 1, cglwd = 0.8,
    # Customize the axis
    # axislabcol = "#889999", 
    axislabcol = "#A7C6DD", 
    # Variable labels
    vlcex = vlcex, vlabels = vlabels,
    caxislabels = caxislabels, title = title, ...
  )
}
# colors()

for(i in 1:g){
	# avg_vals_df[c(1,2,i),]
	create_beautiful_radarchart(RADAR_MATRIX[c(1,2,i+2),],title=treat[i])
}

```



## Differenze discrete
```{r}
##### Parameters #########
PLOT_BOXPLOT=0
##### Parameters #########

nstates = length(levels(Glabel))
for (i in 1:length(model_variables) ){

scelta = model_variables[i]

group_ordered <- with(df_social,                      
                  reorder(df_social$CNT,
                          df_social[,scelta],
                          FUN=mean,
                  		decreasing = T))
	if(PLOT_BOXPLOT==1){
		boxplot(df_social[,scelta] ~ group_ordered,
			main=paste(scelta,"ordered by mean"),las=2,
			ylim=c(round(min(df_social[,scelta])),
				   round(max(df_social[,scelta]))),
			col = rev(colora(length(levels(Glabel)),43)))
		abline(h=mean(df_social[,scelta]))
	}
	
	medie = tapply(df_social[,scelta],group_ordered,mean)
	end = length
	differenze_discrete = round(medie[1:end(medie)-1] - medie[2:end(medie)],digits=4)
	differenze_discrete = round(as.data.frame(differenze_discrete),digits=4)$differenze_discrete

	max1 = max(differenze_discrete)
	max2 = max(setdiff(differenze_discrete,max1))
	
		plot(1:nstates,medie,type="b",main=scelta,ylab="medie(black) & ddif(blue)")
		axis(side = 1, at = 1:13, labels = rownames(data.frame(medie)),las=2)
		points(1:nstates,medie,pch=19,main=scelta)
		lines(1:(nstates-1),differenze_discrete+mean(medie),type="b",col="blue")
	abline(v=which(differenze_discrete==max1))
	abline(v=which(differenze_discrete==max2))
	
	
	# Quality = rep("0",length(Glabel))
	# Quality
	# fit_complete = aov(as.matrix(Xtarget) ~ Glabel + Blabel + Glabel:Blabel)
	# fit_complete = aov(as.matrix(Xtarget) ~ Glabel)
	# print(model_variables[i])
	# print(summary.aov(fit_complete))
}
```



## Differenze discrete con vincolo passi
```{r}
##### Parameters #########
PLOT_BOXPLOT=1
passi = 2
##### Parameters #########

for (i in 1:length(model_variables) ){

scelta = model_variables[i]

	group_ordered <- with(df_social,                      
                  reorder(df_social$CNT,
                          df_social[,scelta],
                          FUN=mean,
                  		decreasing = T))
	if(PLOT_BOXPLOT==1){
		boxplot(df_social[,scelta] ~ group_ordered,
			main=paste(scelta,"ordered by mean"),las=2,
			ylim=c(round(min(df_social[,scelta])),
				   round(max(df_social[,scelta]))),
			col = rev(colora(length(levels(Glabel)),43)))
		abline(h=mean(df_social[,scelta]))
	}
	
	medie = tapply(df_social[,scelta],group_ordered,mean)
	end = length
	differenze_discrete = round(medie[1:end(medie)-1] - medie[2:end(medie)],digits=4)
	differenze_discrete = round(as.data.frame(differenze_discrete),digits=4)$differenze_discrete

	max1 = max(differenze_discrete)
	max2 = max(setdiff(differenze_discrete,max1))
	massimi = c(max1)
	while( abs(which(differenze_discrete==max1)-which(differenze_discrete==max2))<=passi ){
		massimi = c(massimi,max2)
		max2 = max(setdiff(differenze_discrete,massimi))
	}
	
		plot(1:nstates,medie,type="b",main=scelta,ylab="medie(black) & ddif(blue)")
		points(1:nstates,medie,pch=19,main=scelta)
		axis(side = 1, at = 1:13, labels = rownames(data.frame(medie)),las=2)
		lines(1:(nstates-1),differenze_discrete+mean(medie),type="b",col="blue")
		v1=which(differenze_discrete==max1)
		v2=which(differenze_discrete==max2)
	abline(v=v1)
	abline(v=v2)
	
	print(scelta)
	print("good = c(")
	print(rownames(data.frame(medie))[1:min(v1,v2)])
	print("bad = c(")
	print(rownames(data.frame(medie))[max(v1,v2):end(medie)])
	
	# Quality = rep("0",length(Glabel))
	# Quality
	# fit_complete = aov(as.matrix(Xtarget) ~ Glabel + Blabel + Glabel:Blabel)
	# fit_complete = aov(as.matrix(Xtarget) ~ Glabel)
	# print(model_variables[i])
	# print(summary.aov(fit_complete))
}
```


## View on boxplot and maps
```{r}
all_countries <- c(
	"AUT", "BEL", "BGR", "CYP", "CZE", "DEU", "DNK", "ESP", "EST", "FIN",
	"FRA", "GRC", "HRV", "HUN", 
	# "IRL", # IRL non c'è quindi magari possiamo toglierla e avere spazio?
	"ITA", "LTU", "LUX", "LVA", "MLT",
	"NLD", "POL", "PRT", "ROU", "SVK", "SVN", "SWE", 
	"BIH", "ALB","MNE" # queste erano per chiudere la mappa
	)

europe_map <- ne_countries( scale=50,returnclass = 'sf',continent = "europe")
sf_use_s2(FALSE)
centroids <- st_centroid(europe_map)

europe_map <- cbind(europe_map, st_coordinates(st_centroid(europe_map$geometry)))
```

```{r}
for (i in 1:length(model_variables) ){
# for (i in 1:4 ){
	
	#### Classic boxplot
	group_ordered <- with(df_social,                      
                  reorder(df_social$CNT,
                          df_social[,model_variables[i]],
                          FUN=mean,
                  		decreasing = T))
	boxplot(df_social[,model_variables[i]] ~group_ordered,
			main=paste(model_variables[i],"ordered by mean"),las=2,
			ylim=c(round(min(df_social[,model_variables[i]])),
				   round(max(df_social[,model_variables[i]]))),
			col = rev(colora(length(levels(Glabel)),43)))
	abline(h=mean(df_social[,model_variables[i]]))

	
	#### Map stuff
	mean_lab_1<-tapply(df_social[,model_variables[i]],Glabel,mean)
    means = data.frame(mean_lab_1,names(mean_lab_1))
    colnames(means)=c("mean_value","adm0_a3")
    for (country in all_countries) {
      # Check if the country is already in the dataset
      if (!(country %in% means$adm0_a3)) {
        # If not, add the country to the dataset with a value of 0
        means <- rbind(means, data.frame(adm0_a3 = country, mean_value = NA))
      }
    }

    europe_joined <- merge(europe_map, means, by = c("adm0_a3"))
    
    suppressWarnings({print(
      europe_joined %>% ggplot(aes(fill = mean_value)) +
      geom_sf(size = 0.2, color = "black") + # border line
     scale_fill_continuous(
      type = "viridis",
      name = "score",                  # title of the legend
      na.value = "white",  # Specify the color for NA values
      guide = guide_colorbar(
        direction = "vertical",             # vertical colorbar
        title.position = "top",             # title displayed at the top
        label.position = "right",           # labels displayed at the right side
        barwidth = unit(0.4, "cm"),         # width of the colorbar
        barheight = unit(7, "cm"),          # height of the colorbar
        ticks = TRUE))+
      labs(
        title =model_variables[i],
        subtitle = "ANOVA") +
      scale_x_continuous(limits = c(-10, 35)) +
      scale_y_continuous(limits = c(35, 68))+
      theme_void()+
      geom_text_repel(aes(x = X, y = Y, label = name),
        data = subset(europe_joined, !is.na(mean_value)),
        size = 3,                   # Increase the size of the labels
        colour = "gray20",          # Set the color of the labels
        position = position_dodge(width = 0),
        fontface = "bold",          # Set the font weight to bold
        # label.padding = unit(0.5, "lines"),   # Add padding around the label
        # label.r = unit(0.2, "lines"),         # Set the radius of the label's rounded corners
        # label.color = "black",                 # Set the color of the label's border
        # label.size = 0.8,                      # Set the size of the label's border
        # label.fill = "black"                    # Set the color of the label's background
                )
    
    
    )})
}
```


## Discrete maps (??)

```{r}
##########################
COLORI = colora(nstates,20)
# darker is better
##########################

# for (i in 1:length(model_variables) ){
for (i in 1:4 ){
	
	#### Classic boxplot
	group_ordered <- with(df_social,                      
                  reorder(df_social$CNT,
                          df_social[,model_variables[i]],
                          FUN=mean,
                  		decreasing = T))
	boxplot(df_social[,model_variables[i]] ~group_ordered,
			main=paste(model_variables[i],"ordered by mean"),las=2,
			ylim=c(round(min(df_social[,model_variables[i]])),
				   round(max(df_social[,model_variables[i]]))),
			col = COLORI)
	abline(h=mean(df_social[,model_variables[i]]))

	
	#### Map stuff
	mean_lab_1<-tapply(df_social[,model_variables[i]],Glabel,mean)
    means = data.frame(mean_lab_1,names(mean_lab_1))
    colnames(means)=c("mean_value","adm0_a3")
    for (country in all_countries) {
      # Check if the country is already in the dataset
      if (!(country %in% means$adm0_a3)) {
        # If not, add the country to the dataset with a value of 0
        means <- rbind(means, data.frame(adm0_a3 = country, mean_value = NA))
      }
    }

    europe_joined <- merge(europe_map, means, by = c("adm0_a3"))
    suppressWarnings({print(
      europe_joined %>% ggplot(aes(fill = factor(mean_value))) +
      geom_sf(size = 0.2, color = "black") + # border line
    scale_fill_manual(
      name = "legend", 
      breaks = levels(means$mean_value),
      ############### COLORI
      # values =colora(length(levels(means$mean_value)), 24),
      values = rev(COLORI),
      # values =colora(14,26),
      ############### COLORI
      labels = c("high", "medium", "low"),
      na.value = "white"  # Specify the color for NA values
      ) +
      labs(
        title =model_variables[i],
        subtitle = "darker is better") +
        # subtitle = "ANOVA") +
	    # 	 theme(plot.title = element_text(hjust = 1, vjust = 0.5),
	    #        plot.subtitle = element_text(hjust = 0, vjust = 0.5)) +
      scale_x_continuous(limits = c(-10, 35)) +
      scale_y_continuous(limits = c(35, 68))+
      theme_void()+
      # geom_text(aes(x = X, y = Y, label = name),
      geom_text_repel(aes(x = X, y = Y, label = name),
        data = subset(europe_joined, !is.na(mean_value)),
        size = 3,                   # Increase the size of the labels
    	seed=26,
        # colour = "gray20",          # Set the color of the labels
        colour = "#19124D",          # Set the color of the labels
        position = position_dodge(width = 0),
        fontface = "bold",          # Set the font weight to bold
        force=0.9,
        # label.padding = unit(0.5, "lines"),   # Add padding around the label
        # label.r = unit(0.2, "lines"),         # Set the radius of the label's rounded corners
        # label.color = "black",                 # Set the color of the label's border
        # label.size = 0.8,                      # Set the size of the label's border
        # label.fill = "black"                    # Set the color of the label's background
                )
    
    
    )})
}
```


## BSCIs for the difference in the groups

```{r}
# If we reject H0, which supplement is responsible for this? We
# do g*(g-1)/2 comparisons (all the pairs in g groups, g choose 2).
# We use Bonferroni as we look simultaneously at the intervals
g = length(levels(Glabel))
k = g*(g-1)/2
n = dim(df_social)[1]
treat = levels(Glabel)
alpha = 0.05
ng = table(Glabel) # number of obs in each group

for (k in 1:length(model_variables) ){
		
	Xtarget = data.frame(df_social[,model_variables[k]])
	fit = aov(as.matrix(Xtarget) ~ Glabel)
	Mediag = tapply(df_social[,model_variables[k]], df_social$CNT, mean) # group-wise means
	SSres = sum(residuals(fit)^2)
	S = SSres/(n-g)
	ICrange=NULL
	for(i in 1:(g-1)) {
	for(j in (i+1):g) {
	# print(paste(treat[i],"-",treat[j]))
	# print(as.numeric(c(Mediag[i]-Mediag[j] - qt(1-alpha/(2*k), n-g) * sqrt(S * ( 1/ng[i] + 1/ng[j])), Mediag[i]-Mediag[j] + qt(1-alpha/(2*k), n-g) * sqrt(S * ( 1/ng[i] + 1/ng[j])))))
	ICrange=rbind(ICrange,as.numeric(c(Mediag[i]-Mediag[j]
	- qt(1-alpha/(2*k), n-g) * sqrt(S * (1/ng[i] + 1/ng[j])),
	Mediag[i]-Mediag[j]
	+ qt(1-alpha/(2*k), n-g) * sqrt(S * (1/ng[i] + 1/ng[j])))))
	}
	}
	# ICrange
	# par(mfrow=c(1,2))
	# plot(df_social$CNT, df_social[,model_variables[i]], xlab='', ylab='Discriminant variable',
		 # col = colori_fun(g), las=2)
	h = 1
	plot(c(1,g*(g-1)/2),range(ICrange), pch='',
		 xlab='Pairs treatment', ylab='CI tau target variable',
		 main = model_variables[k])
	for(i in 1:(g-1)) {
	for(j in (i+1):g) {
	ind = (i-1)*g-i*(i-1)/2+(j-i)
	if( (ICrange[ind,1]<0 && ICrange[ind,2]<0) || (ICrange[ind,1]>0 && ICrange[ind,2]>0) ){
	lines (c(h,h), c(ICrange[ind,1],ICrange[ind,2]), col='grey55');
	# points(h, Mediag[i]-Mediag[j], pch=16, col='grey55');
	points(h, ICrange[ind,1], col=colori_fun(g)[j], pch=16);
	points(h, ICrange[ind,2], col=colori_fun(g)[i], pch=16);
	}
	h = h+1
	}}
	abline(h=0)
	legend("topright",treat,fill=colori_fun(g),bty="n",cex=0.6)
}
```

# ????????????????????
Non molto rilevante la parte da qui in poi.

## [2] Anova with IM_PUBLIC
```{r}
for (i in 1:length(model_variables) ){
	Xtarget = data.frame(df_social[,model_variables[i]])
	# fit_complete = aov(as.matrix(Xtarget) ~ Glabel + Blabel + Glabel:Blabel)
	fit_complete = aov(as.matrix(Xtarget) ~ Blabel)
	print(model_variables[i])
	print(summary.aov(fit_complete))
}
```
## View on boxplot
```{r}
for (i in 1:length(model_variables) ){
# for (i in 1:4 ){
	
	#### Classic boxplot
	group_ordered <- with(df_social,                      
                  reorder(df_social$IM_PUBLIC,
                          df_social[,model_variables[i]],
                          FUN=mean,
                  		decreasing = T))
	boxplot(df_social[,model_variables[i]] ~group_ordered,
			main=paste(model_variables[i],"ordered by mean"),las=2,
			ylim=c(round(min(df_social[,model_variables[i]])),
				   round(max(df_social[,model_variables[i]]))),
			col = rev(colora(length(levels(Blabel)),43)))
	abline(h=0)
}
```

## [3] Anova with NEW_VAR
```{r}
for (i in 1:length(model_variables) ){
	Xtarget = data.frame(df_social[,model_variables[i]])
	# fit_complete = aov(as.matrix(Xtarget) ~ Glabel + Blabel + Glabel:Blabel)
	fit_complete = aov(as.matrix(Xtarget) ~ GBlabel)
	print(model_variables[i])
	print(summary.aov(fit_complete))
}
```

## View on boxplot

```{r}
for (i in 1:length(model_variables) ){
# for (i in 1:4 ){
	
	#### Classic boxplot
	group_ordered <- with(df_social,                      
                  reorder(df_social$NEW_VAR,
                          df_social[,model_variables[i]],
                          FUN=mean,
                  		decreasing = T))
	boxplot(df_social[,model_variables[i]] ~group_ordered,
			main=paste(model_variables[i],"ordered by mean"),las=2,
			ylim=c(round(min(df_social[,model_variables[i]])),
				   round(max(df_social[,model_variables[i]]))),
			col = rev(colora(length(levels(GBlabel)),43)))
	abline(h=0)
}
```


## BSCIs for the difference in the groups

```{r}
# If we reject H0, which supplement is responsible for this? We
# do g*(g-1)/2 comparisons (all the pairs in g groups, g choose 2).
# We use Bonferroni as we look simultaneously at the intervals
g = length(levels(GBlabel))
k = g*(g-1)/2
n = dim(df_social)[1]
treat = levels(GBlabel)
alpha = 0.05
ng = table(GBlabel) # number of obs in each group

for (k in 1:length(model_variables) ){
		
	Xtarget = data.frame(df_social[,model_variables[k]])
	fit = aov(as.matrix(Xtarget) ~ GBlabel)
	Mediag = tapply(df_social[,model_variables[k]], df_social$NEW_VAR, mean) # group-wise means
	SSres = sum(residuals(fit)^2)
	S = SSres/(n-g)
	ICrange=NULL
	for(i in 1:(g-1)) {
	for(j in (i+1):g) {
	# print(paste(treat[i],"-",treat[j]))
	# print(as.numeric(c(Mediag[i]-Mediag[j] - qt(1-alpha/(2*k), n-g) * sqrt(S * ( 1/ng[i] + 1/ng[j])), Mediag[i]-Mediag[j] + qt(1-alpha/(2*k), n-g) * sqrt(S * ( 1/ng[i] + 1/ng[j])))))
	ICrange=rbind(ICrange,as.numeric(c(Mediag[i]-Mediag[j]
	- qt(1-alpha/(2*k), n-g) * sqrt(S * (1/ng[i] + 1/ng[j])),
	Mediag[i]-Mediag[j]
	+ qt(1-alpha/(2*k), n-g) * sqrt(S * (1/ng[i] + 1/ng[j])))))
	}
	}
	# ICrange
	# par(mfrow=c(1,2))
	# plot(df_social$CNT, df_social[,model_variables[i]], xlab='', ylab='Discriminant variable',
		 # col = colori_fun(g), las=2)
	h = 1
	plot(c(1,g*(g-1)/2),range(ICrange), pch='',
		 xlab='Pairs treatment', ylab='CI tau target variable',
		 main = model_variables[k])
	for(i in 1:(g-1)) {
	for(j in (i+1):g) {
	ind = (i-1)*g-i*(i-1)/2+(j-i)
	if( (ICrange[ind,1]<0 && ICrange[ind,2]<0) || (ICrange[ind,1]>0 && ICrange[ind,2]>0) ){
		lines (c(h,h), c(ICrange[ind,1],ICrange[ind,2]), col='grey55');
		# points(h, Mediag[i]-Mediag[j], pch=16, col='grey55');
		points(h, ICrange[ind,1], col=colori_fun(g,1)[j], pch=16);
		points(h, ICrange[ind,2], col=colori_fun(g,1)[i], pch=16);
	}
	h = h+1
	}}
	abline(h=0)
	legend("topright",treat,fill=colori_fun(g,1),bty="n",cex=0.4)
}
```





