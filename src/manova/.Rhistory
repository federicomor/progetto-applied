qT
qT * sqrt(diag(W)[k]/(n-g) * (1/num_groups[i]+1/num_groups[j]))
(1/num_groups[i]+1/num_groups[j])
diag(W)
summary(pisa)
summary(data)
#directories
working_dir ="/Users/marcogalliani/Desktop/progetto-applied"
dataset_dir = "../data"
include_dir = paste(working_dir,"/src/include/Utilities.R",sep="")
#including utilities
#including utilities
source(include_dir)
#importing the dataset
pisa_data <- read.csv(file=paste(working_dir,"/data/pisa-woNA_school_final.csv",sep=""))
data<-pisa_data
dim(data)
colnames(data)
library(MVN)
library(car)
library(heplots)
library(mvnormtest)
#select only ICT moments fot the moment
library(dplyr)
data <- data %>% dplyr::select(all_of(c("CNT",stu_PROF)))
# what column identify the group?
lab_index <- 1
p = dim(data)[2]
p
v = c()
# Re-name
colnames(data)[lab_index]="label"
head(data)
cols <- seq(1,p)
feats <- cols[!cols %in% lab_index]
data.feats = data[,feats]
data$label<-as.factor(data$label)
p     = length(feats) #don't count the column of labels
# Dimensions
n     = length(data$label) # total number of obs.
ng    = table(data$label)  # number of obs. in each group
treat_factors <- factor(data$label)
treat = levels(treat_factors) # levels of the treatment
g     = length(treat)      # number of levels (i.e., of groups)
indeces = list()
for (jj in 1:g){
indeces[jj] <- list(which(data$label == treat[jj]))
}
n_list = list()
for(j in 1:g) {
n_list[j] = list(length(indeces[[j]]))
}
n=0
for(j in 1:g) {
n = n +  n_list[[j]]
}
# Plot: different panels -> different group
#x11()
par(mfrow=c(2,g/4))
for (j in 1:(g/2)){
boxplot(data.feats[as.numeric(indeces[[j]]),], main=paste('group ',j),  ylim=c(round(min(data.feats)),
round(max(data.feats))), col = rainbow(g)[j])
}
#x11()
par(mfrow=c(4,g/8))
for (j in (g/2+1):g){
boxplot(data.feats[as.numeric(indeces[[j]]),], main=paste('group ',j),  ylim=c(round(min(data.feats)),
round(max(data.feats))), col = rainbow(g)[j])
}
# Plot: different panels -> different group
#x11()
par(mfrow=c(2,g/4))
for (j in 1:(g/2)){
boxplot(data.feats[as.numeric(indeces[[j]]),], main=paste('group ',j),  ylim=c(round(min(data.feats)),
round(max(data.feats))), col = rainbow(g)[j])
}
#x11()
par(mfrow=c(4,g/8))
for (j in (g/2+1):g){
boxplot(data.feats[as.numeric(indeces[[j]]),], main=paste('group ',j),  ylim=c(round(min(data.feats)),
round(max(data.feats))), col = rainbow(g)[j])
}
for (j in (g/2+1):g){
boxplot(data.feats[as.numeric(indeces[[j]]),], main=paste('group ',j),  ylim=c(round(min(data.feats)),
round(max(data.feats))), col = rainbow(g)[j])
}
par(mfrow=c(4,g/8))
for (j in (g/2+1):g){
boxplot(data.feats[as.numeric(indeces[[j]]),], main=paste('group ',j),  ylim=c(round(min(data.feats)),
round(max(data.feats))), col = rainbow(g)[j])
}
par(mfrow=c(4,g/8))
for (j in (g/2+1):g){
boxplot(data.feats[as.numeric(indeces[[j]]),], main=paste('group ',j),  ylim=c(round(min(data.feats)),
round(max(data.feats))), col = rainbow(g)[j])
}
quartz()
par(mfrow=c(4,g/8))
for (j in (g/2+1):g){
boxplot(data.feats[as.numeric(indeces[[j]]),], main=paste('group ',j),  ylim=c(round(min(data.feats)),
round(max(data.feats))), col = rainbow(g)[j])
}
fit = manova(as.matrix(data.feats) ~ data$label)
summary.manova(fit, test="Wilks")
# Pr(>F) = p-value of H0 vs. H1
# If it is very small -> H1 -> the treatment was effective
# Comment
# If p<=2 and g<=3 we have an exact test (with Wilks)
Ps_mvn <- NULL
for(j in 1:g) {
mvn.test <- mvn(data = data[indeces[[j]] , feats])
Ps_mvn <- c(Ps_mvn, mvn.test$multivariateNormality$`p value`)
}
Ps_mvn
# 2. same covariance structure (homoschedasticity)
S  = cov(data.feats)
Slist = list()
for (j in 1:g){
Slist[j] = list(cov(data.feats[indeces[[j]],]))
# Qualitatively:
round(Slist[[j]],digits=1)
}
summary(boxM(data.feats, treat_factors))
temp <- do.call(rbind, Slist)
for (j in 1:g){
image(Slist[[j]], col=heat.colors(100),main=paste('Cov. S',j), asp=1, axes = FALSE,
breaks = quantile(temp, (0:100)/100, na.rm=TRUE))
}
# First of all:
#   Let's see on which variables the group has an effect.
#   Via ANOVA: for each feature we perform an ANOVA to see if the belonging to
#   the group has an effect on the mean of the variables.
summary.aov(fit,test="Wilks")
# Comment
# Pr(>F) = p-value small -> the group has an influence on that X_k
# This analysis does NOT say either which groups differ nor which are the variables
# for which the groups differ.
# First of all:
#   Let's see on which variables the group has an effect.
#   Via ANOVA: for each feature we perform an ANOVA to see if the belonging to
#   the group has an effect on the mean of the variables.
summary.aov(fit,test="Wilks")
# Comment
# Pr(>F) = p-value small -> the group has an influence on that X_k
# This analysis does NOT say either which groups differ nor which are the variables
# for which the groups differ.
alpha = 0.0001
k     = p*g*(g-1)/2
qT    = qt(1-alpha/(2*k), n-g)
W1 <- diag(t(fit$res) %*% fit$res) # fit$re^2
SSres <- sum(W1)
var = SSres/(n-g)
W     = summary.manova(fit)$SS$Residuals
SSres == sum(diag(W))
m  = sapply(data.feats,mean)      # estimates mu
m_list = list()
for (j in 1:g){
m_list[j] = list(sapply(data.feats[indeces[[j]],],mean)) # estimates mu.1=mu+tau.j
}
mg <- do.call(rbind, m_list)
mg
inf_list = list()
sup_list = list()
mean_list = list()
## be careful, order could be reversed
for(i in 1:(g-1)) {
for(j in (i+1):g) {
ind <- (i-1)*g-i*(i-1)/2+(j-i)
inf_list[ind] <- list(m_list[[i]]- m_list[[j]] - qT * sqrt( diag(W)/(n-g)
*(1/n_list[[i]]+1/n_list[[j]])))
mean_list[ind]<-list(m_list[[i]]- m_list[[j]])
sup_list[ind] <- list(m_list[[i]]- m_list[[j]] + qT * sqrt( diag(W)/(n-g)
*(1/n_list[[i]]+1/n_list[[j]])))
}
}
CI = list()
for(i in 1:ind){
CI[i] <- list(cbind(inf = inf_list[[i]],mean = mean_list[[i]], sup = sup_list[[i]]))
}
names_CI<-c()
for(i in 1:(g-1)) {
for(j in (i+1):g) {
names_CI<-c(names_CI,paste(treat[i],treat[j]))
}
}
names(CI)<-names_CI
# Now we have a complete frame (intervals for all the components of tau_i)
# Comment
#   From these intervals we can see who is responsable for the change:
#   if the zero is NOT present in a comparison 'gi_gj' in an interval 'Xk'
#   then the variable 'Xk' is influenced by groups 'gi' and 'gj'.
# Plot: different panels -> different features
country_groups = list()
### cambia nome titolo
for(k in 1:p){
#x11()
#par(mfrow=c(2,1))
# Order boxes by mean (could also be done by median)
group_ordered <- with(data,
reorder(data$label,data.feats[,k],mean))
group_k = list()
counter = 1
boxplot(data.feats[,k]~group_ordered, main=paste(colnames(data.feats)[k]),las=2,
ylim=c(round(min(data.feats[,k])),
round(max(data.feats[,k]))), col = rainbow(g))
abline(h=0)
plot(c(1,g-1), xlim=c(c(1,g-1)), pch='',ylim=c(min(unlist(CI)),max(unlist(CI))),
xlab='pairs treat', ylab=paste('CI tau',colnames(data.feats)[k]),
main=paste('CItau',colnames(data.feats)[k]))
abline(h=0)
i=1
subgroup = levels(group_ordered)[i]
j=2
h=1
while(j!=g){
temp <- sort(c(levels(group_ordered)[i],levels(group_ordered)[j]))
ind<-paste(temp[1],temp[2])
if(CI[[ind]][k,1]*CI[[ind]][k,3]<0){ # zero in the interval
subgroup <- c(subgroup, levels(group_ordered)[j] )
j=j+1
}
else{
group_k[counter]<-list(subgroup)
counter = counter +1
print( names(CI[ind]))
lines (c(h,h), c(CI[[ind]][k,1],CI[[ind]][k,3]));
points(h, CI[[ind]][k,1], col=rainbow(g)[j], pch=16);
points(h, CI[[ind]][k,2], col="black", pch=16);
points(h, CI[[ind]][k,3], col=rainbow(g)[i], pch=16);
i=j
subgroup = levels(group_ordered)[i]
j=i+1
h=h+1
}
}
print("####")
group_k[counter]<-list(levels(group_ordered)[i:length(levels(group_ordered))])
country_groups[k] = list(group_k)
}
print(country_groups)
# Comment
#   If no one contains 0 it means that every group has relevance in every feature.
# working_dir ="C:/Users/modin/Desktop/Ettore/UNIVERSITA/PISA_PROJECT/progetto-applied"
# dataset_dir = "../data"
## dovrebbe funzionare anche senza dare il percorso completo ma usando solo questo:
dataset_dir = "../../data/"
## cioè usaando la posizione relativa dal file
## perché vuol dire vai due cartelle indietro da qui, e poi in data
## e quindi anche qui
# include_dir = paste(working_dir,"/src/include/Utilities.R",sep="")
include_dir = "../include/Utilities.R"
#including utilities
source(include_dir)
#importing the dataset
#including utilities
pisa_data <- read.csv(file=paste0(dataset_dir,"/pisa-woNA_school_final.csv",sep=""))
#variabili finite nel dataset
tec=c("ICTCLASS","ICTHOME","ICTOUTSIDE","ICTRES","AUTICT","COMPICT","INTICT","ENTUSE","HOMESCH","USESCH")
psi=c("ATTLNACT","EMOSUPS","COMPETE","EUDMO","GFOFAIL","SWBP","RESILIENCE","BELONG","BEINGBULLIED","PERFEED")
clt=c("JOYREAD","CULTPOSS","HEDRES","SCREADCOMP","LMINS","MMINS")
fam=c("WEALTH","ESCS","HOMEPOS","BFMJ2","BMMJ1","HISCED","HISEI")
tch=c("TEACHINT","TEACHSUP","STIMREAD")
sch=c("PERCOMP","PERCOOP","ICTSCH","RATCMP1") #,"RATCMP2")
variabole_groups = list(tec,psi,clt,fam,sch)
G = length(variabole_groups)
n = dim(pisa_data)[1]
p = dim(pisa_data)[2]
# all toghether
pisa.fa <- factanal(pisa_data[,c(4:p)], factors = 5, rotation = "varimax")
pisa.fa
pisa.pca <-princomp(pisa_data[,4:p])
pisa.fa$loadings
pisa.load = pisa.pca$loadings
x11()
par(mfcol=c(3,1))
for(i in 1:2) barplot(pisa.load[,i] ,las=2,ylim = c(-1, 1), main=paste("PC Loadings",i))
x11()
par(mfcol=c(3,1))
for(i in 3:4:5) barplot(pisa.load[,i] ,las=2,ylim = c(-1, 1), main=paste("PC Loadings",i))
# i factor più importanti sembrano mmins e lmins, perché?
colnames(pisa_data)
x11()
boxplot(pisa_data[,5:44], las=2, main="pisa cols")
# forse le prende perché hanno alta varianza?
#fam,2
#tec,5
#tch,1
var = tch
factors= 2
pisa.fa <- factanal(pisa_data[,var], factors = factors,rotation = "varimax")
source("../include/Utilities.R")
#variabili finite nel dataset
tec=c("ICTCLASS","ICTHOME","ICTOUTSIDE","ICTRES","AUTICT","COMPICT","INTICT","ENTUSE","HOMESCH","USESCH")
psi=c("ATTLNACT","EMOSUPS","COMPETE","EUDMO","GFOFAIL","SWBP","RESILIENCE","BELONG","BEINGBULLIED","PERFEED")
clt=c("JOYREAD","CULTPOSS","HEDRES","SCREADCOMP","LMINS","MMINS")
fam=c("WEALTH","ESCS","HOMEPOS","BFMJ2","BMMJ1","HISCED","HISEI")
tch=c("TEACHINT","TEACHSUP","STIMREAD")
sch=c("PERCOMP","PERCOOP","ICTSCH","RATCMP1") #,"RATCMP2")
df=read.csv("../../data/pisa-woNA_school_final.csv")
colnames(df)
head(df)
df=df[,-c(1)] #remove  X (index) column
sort(colnames(df[,-c(1,2,3)])) == sort(c(tec,psi,clt,fam,tch,sch))
#c'è tutto ora
#variabili nuove
colnames(df)[c(1,2,3)]
head(df$schID)
length(unique(df$schID))
dim(df) #è davvero un id allora
head(df$gender_prop) #??
df_tec = df[,colnames(df) %in% tec]
df_psi = df[,colnames(df) %in% psi]
df_clt = df[,colnames(df) %in% clt]
df_fam = df[,colnames(df) %in% fam]
df_tch = df[,colnames(df) %in% tch]
df_sch = df[,colnames(df) %in% sch]
states = unique(df$CNT)
len = length(unique(df$CNT))
hcl.pals()
col.ramp = hcl.colors(len, palette = "viridis")
boxplot(df$SWBP ~ df$CNT,las=2, col=col.ramp, main="SWBP for states, by-school dataset")
```{r}
```{r}
## SWBP for schools in states
```{r}
unique(df$CNT)
unique(df$CNT)
for(state in states){
plot(df$SWB[which(df$CNT==state)] ~ df$schID[which(df$CNT==state)], main=paste("SWBP for the schools in",state))
}
## Comparison of the means in states
```{r}
library(multkw.m)
install.packages("multkw.m")
library(MKW)
#' @title Multivariate Kruskal-Wallis test
#'
#' @description This function computes a multivariate Kruskal-Wallis test for n numeric variables relative to one factorial variable (that subsets the dataset in groups)
#'
#' @details
#' A "standard" multivariate Kruskal-Wallis test is computed, deleting all missing data.
#'
#' @author Fanyin He (most of the statistical function)
#' @author Jacob Maugoust (packaging)
#'
#' @seealso
#' See chapter 2.2.2 and 4.2 of the \href{http://d-scholarship.pitt.edu/19411/1/Fanyin_ETD_draft_08-06-2013.pdf}{PhD manuscript of Fanyin He} and 'Methodology' of \insertCite{He.etal.2017;textual}{ULT} for more details.
#'
#' @param group The factorial variable that subsets the dataset in groups. Can be a character vector, a factorial vector or an integer/numeric vector.
#' @param y The dataset of n numeric(or integer) variables.
#' @param print Whether the test should be printed (\code{TRUE}, the default) or not (e.g., to be stored in an object)
#'
#' @return Output is either a list (with \code{"simplify=FALSE"}) or a vector (with \code{"simplify=TRUE"}) containing the results of the multivariate Kruskal-Wallis test.
#'
#' @importFrom stats aggregate pchisq
#' @importFrom Matrix bdiag
#' @import lattice
#'
#' @references
#' \insertRef{He.etal.2017}{ULT}
#'
#' @examples
#' data(airquality)
#' datamkw<-airquality[,1:4]
#' multkw(y=datamkw,airquality$Month)
#'
#' @export
multkw<- function(group,y,print=TRUE){
group.var.name<-deparse(substitute(group))
y.var.name<-deparse(substitute(y))
# sort and rank data by group #
o<-order(group)
group<-group[o]
if(ncol(as.matrix(y))==1){y<-as.matrix(y[o])}
else{y<-as.matrix(y[o,])}
n<-length(group)
p<-dim(y)[2]
if(dim(y)[1]!=n){return("number of observations not equal to length of group")}
groupls<-unique(group)
g<-length(groupls) # number of groups
groupind<-sapply(groupls,"==",group) # group indicator
ni<-colSums(groupind) # number of individuals of each group
r<-apply(y,2,rank) # corresponding rank variable
# calculation of statistic #
r.ik<-t(groupind)%*%r*(1/ni) # gxp, mean rank of k-th variate in i-th group
m<-(n+1)/2 # expected value of rik
u.ik<-t(r.ik-m)
U<-as.vector(u.ik)
V<-1/(n-1)*t(r-m)%*%(r-m) # pooled within-group cov matrix
Vstar<-bdiag(lapply(1/ni,"*",V))
W2<-as.numeric(t(U)%*%solve(Vstar)%*%U)
df<-p*(g-1)
pv<-pchisq(W2,p*(g-1),lower.tail = FALSE)
multkw.results<-list(y=y.var.name,group=group.var.name,test.statistic=W2,df=df,p.value=pv)
class(multkw.results)<-"multkw.output"
if(print){print(multkw.results)}
else{return(multkw.results)}
}
#directories
working_dir = "/Users/marcogalliani/Desktop/progetto-applied"
complete_data_dir = "/Users/marcogalliani/Desktop/PISA-dataset/PISA_file_sav"
clean_data_dir = "/Users/marcogalliani/Desktop/PISA-dataset"
include_dir = paste(working_dir,"/src/include/Utilities.R",sep="")
#including utilities
source(include_dir)
#importing the dataset
pisa_data <- read.csv(file=paste(clean_data_dir,"/pisa-woNA.csv",sep=""))
#select only ICT moments fot the moment
library(dplyr)
pisa_data <- pisa_data %>% dplyr::select(all_of(c("CNT",stu_ICT,sch_ICT)))
#dropping spain
pisa_data <- pisa_data %>% filter(CNT!="ESP")
multkw(y=pisa_data,pisa_data$CNT)
library(Matrix)
multkw(y=pisa_data,pisa_data$CNT)
fit <- multkw(y=pisa_data,pisa_data$CNT)
#directories
working_dir = "/Users/marcogalliani/Desktop/progetto-applied"
complete_data_dir = "/Users/marcogalliani/Desktop/PISA-dataset/PISA_file_sav"
clean_data_dir = "/Users/marcogalliani/Desktop/PISA-dataset"
include_dir = paste(working_dir,"/src/include/Utilities.R",sep="")
#including utilities
source(include_dir)
#importing the dataset
pisa_data <- read.csv(file=paste(clean_data_dir,"/pisa-woNA.csv",sep=""))
#select only ICT moments fot the moment
library(dplyr)
pisa_data <- pisa_data %>% dplyr::select(all_of(c("CNT",stu_ICT,sch_ICT)))
#dropping spain
pisa_data <- pisa_data %>% filter(CNT!="ESP")
#' @title Multivariate Kruskal-Wallis test
#'
#' @description This function computes a multivariate Kruskal-Wallis test for n numeric variables relative to one factorial variable (that subsets the dataset in groups)
#'
#' @details
#' A "standard" multivariate Kruskal-Wallis test is computed, deleting all missing data.
#'
#' @author Fanyin He (most of the statistical function)
#' @author Jacob Maugoust (packaging)
#'
#' @seealso
#' See chapter 2.2.2 and 4.2 of the \href{http://d-scholarship.pitt.edu/19411/1/Fanyin_ETD_draft_08-06-2013.pdf}{PhD manuscript of Fanyin He} and 'Methodology' of \insertCite{He.etal.2017;textual}{ULT} for more details.
#'
#' @param group The factorial variable that subsets the dataset in groups. Can be a character vector, a factorial vector or an integer/numeric vector.
#' @param y The dataset of n numeric(or integer) variables.
#' @param print Whether the test should be printed (\code{TRUE}, the default) or not (e.g., to be stored in an object)
#'
#' @return Output is either a list (with \code{"simplify=FALSE"}) or a vector (with \code{"simplify=TRUE"}) containing the results of the multivariate Kruskal-Wallis test.
#'
#' @importFrom stats aggregate pchisq
#' @importFrom Matrix bdiag
#' @import lattice
#'
#' @references
#' \insertRef{He.etal.2017}{ULT}
#'
#' @examples
#' data(airquality)
#' datamkw<-airquality[,1:4]
#' multkw(y=datamkw,airquality$Month)
#'
#' @export
multkw<- function(group,y,print=TRUE){
group.var.name<-deparse(substitute(group))
y.var.name<-deparse(substitute(y))
# sort and rank data by group #
o<-order(group)
group<-group[o]
if(ncol(as.matrix(y))==1){y<-as.matrix(y[o])}
else{y<-as.matrix(y[o,])}
n<-length(group)
p<-dim(y)[2]
if(dim(y)[1]!=n){return("number of observations not equal to length of group")}
groupls<-unique(group)
g<-length(groupls) # number of groups
groupind<-sapply(groupls,"==",group) # group indicator
ni<-colSums(groupind) # number of individuals of each group
r<-apply(y,2,rank) # corresponding rank variable
# calculation of statistic #
r.ik<-t(groupind)%*%r*(1/ni) # gxp, mean rank of k-th variate in i-th group
m<-(n+1)/2 # expected value of rik
u.ik<-t(r.ik-m)
U<-as.vector(u.ik)
V<-1/(n-1)*t(r-m)%*%(r-m) # pooled within-group cov matrix
Vstar<-bdiag(lapply(1/ni,"*",V))
W2<-as.numeric(t(U)%*%solve(Vstar)%*%U)
df<-p*(g-1)
pv<-pchisq(W2,p*(g-1),lower.tail = FALSE)
multkw.results<-list(y=y.var.name,group=group.var.name,test.statistic=W2,df=df,p.value=pv)
class(multkw.results)<-"multkw.output"
if(print){print(multkw.results)}
else{return(multkw.results)}
}
library(Matrix)
fit <- multkw(y=pisa_data,pisa_data$CNT)
fit
summary(fit)
library(npmv)
install.packages("npmv")
library(npmv)
help(npmv)
help(nonpartest)
View(pisa_data)
View(pisa_data)
nonpartest(ICTCLASS|ICTHOME|ENTUSE|ICTHOME ~ CNT,data = pisa=data)
nonpartest(ICTCLASS|ICTHOME|ENTUSE|ICTHOME ~ CNT,data = pisa_data)
quartz()
nonpartest(ICTCLASS|ICTHOME|ENTUSE|ICTHOME~CNT,data = pisa_data)
library(npmv)
help(npmv)
quartz()
nonpartest(ICTCLASS|ICTHOME|ENTUSE|ICTHOME~CNT,data = pisa_data)
