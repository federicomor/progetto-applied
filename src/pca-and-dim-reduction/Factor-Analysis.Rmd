---
title: "Factor Analysis"
output: 
---

# NOTES AND REFERENCES

-   Exploratory Factor Analysis (EFA) tutorial: <https://rpubs.com/pjmurphy/758265>

-   notes from the textbook "Applied Multivariate Statistical Analysis" in the same directory of this folder

-   reference paper of past year project on Well-Being

-   source: <https://www.geo.fu-berlin.de/en/v/soga/Geodata-analysis/factor-analysis/A-simple-example-of-FA/index.htmlZ>

-   according to this article (<https://journals.sagepub.com/doi/full/10.1177/0095798418771807>) it is better to perform EFA only on variables we suspect to be generated by a latent factor. Thus, it is better to follow the same procedure we used for PCA

# PRELIMINARY STUFF

```{r}
#loaded librarires
library(dplyr)
library(psych) #for KMO test and principal()
library(car) #to apply transformations
library(MVN) #to perform multivariate gaussianity check
```

```{r, setup}
#DIRECTORIES
root_proj_dir = "../../"
dataset_dir = paste(root_proj_dir,"/data/pisa_school_wo_Outl.csv",sep="")
include_dir = paste(root_proj_dir,"/src/include/Utilities.R",sep="")
#INCLUDING UTILITIES
source(include_dir)
#IMPORTING THE DATASET
pisa_data <- read.csv(file=dataset_dir)
```

```{r}
#some adjustments on the data
pisa_data$X <- NULL
pisa_data$schID <- NULL
pisa_data$CNT <- as.factor(pisa_data$CNT)
```

```{r}
#variabili finite nel dataset
group_list <- c("tec","psi","clt","fam","tch","sch")
included_variables <-list()
#list of grouped variables
included_variables[["tec"]] <- c("ICTCLASS","ICTHOME","ICTOUTSIDE","ICTRES","AUTICT","COMPICT","INTICT","ENTUSE","HOMESCH","USESCH")
included_variables[["psi"]] <- c("ATTLNACT","EMOSUPS","COMPETE","EUDMO","GFOFAIL","SWBP","RESILIENCE","BELONG","BEINGBULLIED","PERFEED")
included_variables[["clt"]] <- c("JOYREAD","CULTPOSS","HEDRES","SCREADCOMP","LMINS","MMINS")
included_variables[["fam"]] <- c("WEALTH","ESCS","HOMEPOS","BFMJ2","BMMJ1","HISCED","HISEI")
included_variables[["tch"]] <- c("TEACHINT","TEACHSUP","STIMREAD")
included_variables[["sch"]] <- c("PERCOMP","PERCOOP","ICTSCH","RATCMP1")
```

# PREPROCESSING OF DATA

```{r}
#transforming the data: Box-Cox transformation
#must be strictly positive 
transformed_data <- select_if(pisa_data,is.numeric)
transformed_data <- transformed_data+abs(min(transformed_data)) + 1e-5 #1e-5 epsilon per ottenere disuguaglianza stretta

#Box-Cox transformations
#computing lambda
#lambda <- powerTransform(transformed_data) #take long
#I have saved it in since the computation take quite long
#save(lambda,file = "lambda.Rdata")
load("lambda.Rdata") 
#If there are some changes in data I need to compute it again

#transforming data
for(i in length(lambda$lambda)){
   transformed_data[,i]<- bcPower(U=transformed_data[,i],lambda=lambda$lambda[i])
}
#standardizing the data
transformed_data <- as.data.frame(scale(transformed_data))

#add the CNT column
transformed_data["CNT"] <- pisa_data$CNT
transformed_data$X.1 <- NULL

pisa_data <- transformed_data
```

# PERFORMING EFA

Preliminary tests:

-   cortest.bartlett(): test to see if the variables in the dataframe are uncorrellated. H0: correlation matrix sigma = Identity matrix (i.e. uncorrellated variables)

-   KMO: another check on uncorrelation

-   multivariate normality to perform factor analysis with the maximum likelihood estimation method

```{r}
checking_hp <- list()
for(group in group_list){
  #(1) CORRELATION
  #KMO(select_if(pisa_data[,included_variables[[group]]],is.numeric))
  checking_hp[[group]]$correlation <- cortest.bartlett(select_if(pisa_data[,included_variables[[group]]],is.numeric))
  #(2) MULTIVARIATE NORMALITY
  checking_hp[[group]]$normality <- mvn(data = select_if(pisa_data[,included_variables[[group]]],is.numeric), mvnTest = "hz",univariateTest = "SW")
}
```

Selecting the number of factor to select:

```{r}
#eigenvalues method
for(group in group_list){
  #scree plot
  scree(select_if(pisa_data[,included_variables[[group]]],is.numeric), 
        pc=TRUE, 
        main = paste("Scree plot", group))
  #parallel analysis
  fa.parallel(select_if(pisa_data[,included_variables[[group]]],is.numeric), 
              fa="fa", 
              main = paste("Parallel Analysis Scree Plots",group))
  #a method from psych package with many more criteria
  nfactors(cor(select_if(pisa_data[,included_variables[[group]]],is.numeric)),
           title = paste("Number of factors", group))
}
```

Here we're actually performing factor analysis. We have two options to estimate the matrix L of loadings:

-   Maximum Likelihood Estimation: requires multivariate normality on X (factanal function)

-   Principal component method (principal funtion)

```{r}
#storing the number of factors (decision based on the previous plots)
nfactors <- list()
nfactors[["tec"]] <- 4 #eigenval
nfactors[["psi"]] <- 4 #eigenval
nfactors[["clt"]] <- 3 #eigenval
nfactors[["fam"]] <- 2 #eigenval
nfactors[["tch"]] <- 2 #eigenval
nfactors[["sch"]] <- 2 #eigenval
```

```{r}
#maximum likelihoood method: assuming normality (discarded)
#fit_ML <- factanal(x = select_if(pisa_data,is.numeric), 
#                factors = 12, 
#                rotation = "promax",
#                lower = 0.0057)

#principal component method
fit_PC <- list()
for(group in group_list){
  #fitting the factor analysis model
  fit_PC[[group]] <- principal(r = cor(select_if(pisa_data[,included_variables[[group]]],is.numeric)), nfactors = nfactors[[group]], rotate = "promax")
}
```

**A note on rotation:** loading matrix (L) is unique up to rotation made through orthogonal matrices. Thus, we have can provide as an option to this functions a rotation method to ease the interpretability of the loadings. There a two kind of rotations:

-   orthogonal rotation methods: if we assume that the extracted factors are independent

    -   "varimax": optimized to reduce cross loadings and to minimize smaller loading values, making factor models clearer

    -   "quartimax": works to reduce the number of variables needed to explain a factor, making interpretation easier

    -   "equamax": compromise between varimax and quartimax

-   oblique rotation methods: if we assume that the extracted factors are not independent

    -   "promax": Promax rotation is popular for its ability to handle large datasets efficiently. The approach also tends to result in greater correlation values between factors.

    -   The direct oblimin rotation approach is somewhat less efficient with large datasets, but can produce a simpler factor structure.

[reference: <https://rpubs.com/pjmurphy/758265> for]

```{r}
for(group in group_list){
  print(fit_PC[[group]]$loadings)
}
```

Visualizing the loadings:

```{r}
#Maximum-Likelihood method

#Principal Component method
for(group in group_list){
  for(i in 1:dim(fit_PC[[group]]$loadings)[2]){
    barplot(fit_PC[[group]]$loadings[,i], main = paste("factor",group,i),las=2,cex.names=0.7)
  }
}
```
