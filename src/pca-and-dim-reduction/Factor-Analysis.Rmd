---
title: "Factor Analysis"
output: 
editor_options: 
  chunk_output_type: inline
---

# NOTES AND REFERENCES

-   Exploratory Factor Analysis (EFA) tutorial: <https://rpubs.com/pjmurphy/758265>

-   notes from the textbook "Applied Multivariate Statistical Analysis" in the same directory of this folder

-   source: <https://www.geo.fu-berlin.de/en/v/soga/Geodata-analysis/factor-analysis/A-simple-example-of-FA/index.htmlZ>

# PRELIMINARY STUFF

```{r}
#loaded librarires
library(dplyr)
library(psych) #for KMO test and principal()
library(car) #to apply transformations
```

```{r, setup}
#DIRECTORIES
root_proj_dir = "../../"
dataset_dir = paste(root_proj_dir,"/data/pisa_school_wo_Outl.csv",sep="")
include_dir = paste(root_proj_dir,"/src/include/Utilities.R",sep="")
#INCLUDING UTILITIES
source(include_dir)
#IMPORTING THE DATASET
pisa_data <- read.csv(file=dataset_dir)
```

```{r}
#some adjustments on the data
pisa_data$X <- NULL
pisa_data$schID <- NULL
pisa_data$CNT <- as.factor(pisa_data$CNT)
```

```{r}
#variabili finite nel dataset
included_variables <-list()
#list of grouped variables
included_variables[["tec"]] <- c("ICTCLASS","ICTHOME","ICTOUTSIDE","ICTRES","AUTICT","COMPICT","INTICT","ENTUSE","HOMESCH","USESCH")
included_variables[["psi"]] <- c("ATTLNACT","EMOSUPS","COMPETE","EUDMO","GFOFAIL","SWBP","RESILIENCE","BELONG","BEINGBULLIED","PERFEED")
included_variables[["clt"]] <- c("JOYREAD","CULTPOSS","HEDRES","SCREADCOMP","LMINS","MMINS")
included_variables[["fam"]] <- c("WEALTH","ESCS","HOMEPOS","BFMJ2","BMMJ1","HISCED","HISEI")
included_variables[["tch"]] <- c("TEACHINT","TEACHSUP","STIMREAD")
included_variables[["sch"]] <- c("PERCOMP","PERCOOP","ICTSCH","RATCMP1")
```

# PREPROCESSING OF DATA

```{r}
#transforming the data: Box-Cox transformation
#must be strictly positive 
transformed_data <- select_if(pisa_data,is.numeric)
transformed_data <- transformed_data+abs(min(transformed_data)) + 1e-5 #1e-5 epsilon per ottenere disuguaglianza stretta

#Box-Cox transformations
#computing lambda
lambda <- powerTransform(transformed_data)  
#transforming data
for(i in length(lambda$lambda)){
   transformed_data[,i]<- bcPower(U=transformed_data[,i],lambda=lambda$lambda[i])
}
#standardizing the data
transformed_data <- as.data.frame(scale(transformed_data))

#add the CNT column
transformed_data["CNT"] <- pisa_data$CNT
transformed_data$X.1 <- NULL

pisa_data <- transformed_data
```

# PERFORMING EFA

Preliminary tests:

-   cortest.bartlett(): test to see if the variables in the dataframe are uncorrellated. H0: correlation matrix sigma = Identity matrix (i.e. uncorrellated variables)

-   KMO: another check on uncorrelation

```{r}
KMO(select_if(pisa_data,is.numeric))
#values are good
cortest.bartlett(select_if(pisa_data,is.numeric))
```

Selecting the number of factor to select:

```{r}
ev <- eigen(cor(select_if(pisa_data,is.numeric))) # get eigenvalues
ev$values
#eigenvalues method
quartz()
scree(select_if(pisa_data,is.numeric), pc=FALSE)
#parallel analysis
quartz()
fa.parallel(select_if(pisa_data,is.numeric), fa="fa")

#number of factors range: 6-12

#also let's try this method
nfactors(cor(select_if(pisa_data,is.numeric)))
```

Actually performing factor analysis, we have two options to estimate the matrix L of loadings:

-   Maximum Likelihood Estimation: requires multivariate normality on X (factanal function)

-   Principal component method (principal funtion)

**note** loading matrix is unique up to rotation made through orthogonal matrices. Thus, we have can provide as an option to this functions a rotation method to ease the interpretability of the loadings

```{r}
#computing it even if we don't have normality
fit_ML <- factanal(x = select_if(pisa_data,is.numeric), 
                factors = 10, 
                rotation = "varimax",
                lower = 0.0057)
#non parametric
fit_PC <- principal(r = cor(select_if(pisa_data,is.numeric)), 
                factors = 10, 
                rotation = "promax")
```

# PREVIOUS VERSION

```{r}
n = dim(pisa_data)[1]
p = dim(pisa_data)[2]
#all toghether
pisa.fa <- factanal(select_if(pisa_data,is.numeric), factors = 10, rotation = "promax")
pisa.fa
pisa.pca <-princomp(pisa_data[,4:p])
pisa.fa$loadings
pisa.load = pisa.pca$loadings

x11()
par(mfcol=c(3,1))
for(i in 1:2) barplot(pisa.load[,i] ,las=2,ylim = c(-1, 1), main=paste("PC Loadings",i))
x11()
par(mfcol=c(3,1))
for(i in 3:4:5) barplot(pisa.load[,i] ,las=2,ylim = c(-1, 1), main=paste("PC Loadings",i))
```

# analisi sospetti

```{r}
# i factor più importanti sembrano mmins e lmins, perché?
colnames(pisa_data)
x11()
boxplot(pisa_data[,5:44], las=2, main="pisa cols")
# forse le prende perché hanno alta varianza?


```

```{r}
#fam,2
#tec,5
#tch,1
var = tch
factors= 2
pisa.fa <- factanal(pisa_data[,var], factors = factors,rotation = "varimax")
pisa.fa

pisa.load = pisa.pca$loadings

x11()
par(mfcol=c(5,1))
for(i in 1:5) barplot(pisa.load[,i] ,las=2,ylim = c(-1, 1), main=paste("PC Loadings",i))
plot(pisa.fa$loadings[,1], 
     pisa.fa$loadings[,2],
     xlab = "Factor 1", 
     ylab = "Factor 2",
     ylim = c(-1,1),
     xlim = c(-1,1),
     main = "Promax rotation")
abline(h = 0, v = 0)
```
